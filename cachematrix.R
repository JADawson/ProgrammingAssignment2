## These two functions are based on the "makeVector" and "cachemean" examples provided
## I have modified them to work with a matrix input, and apply the solve() calculation to give the inverse
## I have removed the set() method from makeCacheMatrix as this is not necessary
## I have added comments to the code below to demonstrate that I understand the functionality

makeCacheMatrix <- function(x = matrix()) { ## a matrix input is required. I tested this with a simple 2 x 2
                                            ## generated by "mymatrix<-matrix(c(1,2,2,1),nrow=2,ncol=2)"
    
    ##create m and set the value to NULL
    m <- NULL
    
    ## these next 3 functions are really "methods" which will be stored in a list so that they
    ## can be called from elsewhere on the output of makeCacheMatrix 
    get <- function() x ##assigns the matrix "x" to the get() method. calling get() will return the initial matrix 
                        ## which eas supplied
    
    setsolve <- function(solve) m <<- solve ##this method will be used to assign the solve solution to the variable m
                                            ## this is the part which essentially caches the result
    
    getsolve <- function() m ##returns the solution. this is tested for NULL in the if portion of the cacheSolve function
    
    list(get = get,          ##creates a list of the methods so they can be accessed later
         setsolve = setsolve,
         getsolve = getsolve)
}

## cacheSolve is used to calculate the inverse of the matrix supplied to the function makeCacheMatrix
## first it checks whether the solution has been cached in the makeCacheMatrix global variable "m"
## if so, it calls it, otherwise it calculates it and sets it in the list which resulted from makeCacheMatrix

cacheSolve <- function(x, ...) {
    ## Return a matrix that is the inverse of 'x'
    m <- x$getsolve()  ## get the global value of m from the "cache"
    if(!is.null(m)) {  ## if it's available get it from the "cache"
        print("getting cached data")
        return(m)
    }
    data <- x$get()         ##if m is not set in the "cache", call the get() method to pull back the matrix and put it in data
    m <- solve(data, ...)   ## calculate m using the solve() function on data
    x$setsolve(m)           ##call the setsolve() method to push the solution into the "cache" for later use
    print("using new data") ## added a print command to explicitly show that we're using new data rather than "cached"
    return(x$getsolve())    ## return using getsolve(). this used to be just m but this is fancier and shows the solution was 
                            ## pushed to the cache.
}
